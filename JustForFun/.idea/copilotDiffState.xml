<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/just_for_fun/justforfun/data/repository/AuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/just_for_fun/justforfun/data/repository/AuthRepository.kt" />
              <option name="updatedContent" value="package com.just_for_fun.justforfun.data.repository&#10;&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class AuthRepository(&#10;    private val auth: FirebaseAuth = FirebaseAuth.getInstance(),&#10;    private val db: FirebaseFirestore = FirebaseFirestore.getInstance()&#10;) {&#10;    suspend fun signUpWithEmail(&#10;        name: String,&#10;        username: String,&#10;        email: String,&#10;        password: String&#10;    ): String {&#10;        val result = auth.createUserWithEmailAndPassword(email, password).await()&#10;        val uid = result.user?.uid ?: throw IllegalStateException(&quot;User creation failed&quot;)&#10;&#10;        // Reserve username atomically to keep it unique&#10;        db.runTransaction { tr -&gt;&#10;            val unameDoc = db.collection(&quot;usernames&quot;).document(username)&#10;            val snapshot = tr.get(unameDoc)&#10;            if (snapshot.exists()) throw IllegalStateException(&quot;Username already taken&quot;)&#10;            tr.set(unameDoc, mapOf(&quot;uid&quot; to uid))&#10;        }.await()&#10;&#10;        val now = System.currentTimeMillis()&#10;        val userDoc = mapOf(&#10;            &quot;id&quot; to uid,&#10;            &quot;name&quot; to name,&#10;            &quot;email&quot; to email,&#10;            &quot;username&quot; to username,&#10;            &quot;bio&quot; to &quot;&quot;,&#10;            &quot;profilePicture&quot; to &quot;&quot;,&#10;            &quot;joinDate&quot; to now,&#10;            &quot;location&quot; to null,&#10;            &quot;website&quot; to null,&#10;            &quot;following&quot; to emptyList&lt;String&gt;(),&#10;            &quot;followers&quot; to emptyList&lt;String&gt;(),&#10;            &quot;favourites&quot; to emptyList&lt;String&gt;(),&#10;            &quot;watchList&quot; to emptyList&lt;String&gt;(),&#10;            &quot;reviews&quot; to emptyList&lt;String&gt;(),&#10;            &quot;ratings&quot; to emptyList&lt;String&gt;(),&#10;            &quot;likedReviews&quot; to emptyList&lt;String&gt;(),&#10;            &quot;likedReplies&quot; to emptyList&lt;String&gt;(),&#10;            &quot;replies&quot; to emptyList&lt;Map&lt;String, Any?&gt;&gt;(),&#10;            &quot;watchHistory&quot; to emptyList&lt;String&gt;(),&#10;            &quot;socialLinks&quot; to emptyMap&lt;String, String&gt;(),&#10;            &quot;topGenres&quot; to emptyList&lt;String&gt;(),&#10;            &quot;customListMovies&quot; to emptyList&lt;String&gt;(),&#10;            &quot;customShowMovies&quot; to emptyList&lt;String&gt;(),&#10;            &quot;blockedUsers&quot; to emptyList&lt;String&gt;(),&#10;            &quot;preferences&quot; to mapOf(&#10;                &quot;notificationsEnable&quot; to true,&#10;                &quot;emailNotifications&quot; to true,&#10;                &quot;pushNotifications&quot; to true,&#10;                &quot;privateProfile&quot; to false,&#10;                &quot;showWatchHistory&quot; to true,&#10;                &quot;showRatings&quot; to true,&#10;                &quot;showReviews&quot; to true,&#10;                &quot;allowFollowRequests&quot; to true,&#10;                &quot;showOnlineStatus&quot; to true,&#10;                &quot;language&quot; to &quot;en&quot;,&#10;                &quot;theme&quot; to &quot;system&quot;&#10;            ),&#10;            &quot;isPrivate&quot; to false,&#10;            &quot;isVerified&quot; to false,&#10;            &quot;lastActivateDate&quot; to now,&#10;            &quot;totalReviews&quot; to 0,&#10;            &quot;totalRatings&quot; to 0,&#10;            &quot;averageRating&quot; to 0.0&#10;        )&#10;&#10;        db.collection(&quot;users&quot;).document(uid).set(userDoc).await()&#10;        // Attach a claim time to help with analytics or future&#10;        auth.currentUser?.updateProfile(null)&#10;        db.collection(&quot;meta&quot;).document(&quot;users&quot;).set(&#10;            mapOf(&quot;count&quot; to FieldValue.increment(1))&#10;        , com.google.firebase.firestore.SetOptions.merge()).await()&#10;        return uid&#10;    }&#10;&#10;    suspend fun signInWithEmail(email: String, password: String): String {&#10;        val result = auth.signInWithEmailAndPassword(email, password).await()&#10;        return result.user?.uid ?: throw IllegalStateException(&quot;Sign in failed&quot;)&#10;    }&#10;&#10;    fun currentUserId(): String? = auth.currentUser?.uid&#10;&#10;    fun isSignedIn(): Boolean = auth.currentUser != null&#10;&#10;    fun signOut() {&#10;        auth.signOut()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/just_for_fun/justforfun/data/repository/FirebaseRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/just_for_fun/justforfun/data/repository/FirebaseRepository.kt" />
              <option name="originalContent" value="package com.just_for_fun.justforfun.data.repository&#10;&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ktx.toObject&#10;import com.just_for_fun.justforfun.data.models.Movie&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class FirebaseRepository {&#10;    private val firestore = FirebaseFirestore.getInstance()&#10;&#10;    suspend fun saveMovie(movie: Movie) {&#10;        firestore.collection(&quot;movies&quot;)&#10;            .document(movie.id)&#10;            .set(movie)&#10;            .await()&#10;    }&#10;&#10;    suspend fun getMovie(movieId: String): Movie? {&#10;        return firestore.collection(&quot;movies&quot;)&#10;            .document(movieId)&#10;            .get()&#10;            .await()&#10;            .toObject&lt;Movie&gt;()&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package com.just_for_fun.justforfun.data.repository&#13;&#10;&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.google.firebase.firestore.ktx.toObject&#13;&#10;import com.just_for_fun.justforfun.data.models.media.Movie&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;&#13;&#10;class FirebaseRepository {&#13;&#10;    private val firestore = FirebaseFirestore.getInstance()&#13;&#10;&#13;&#10;    suspend fun saveMovie(movie: Movie) {&#13;&#10;        firestore.collection(&quot;movies&quot;)&#13;&#10;            .document(movie.id)&#13;&#10;            .set(movie)&#13;&#10;            .await()&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun getMovie(movieId: String): Movie? {&#13;&#10;        return firestore.collection(&quot;movies&quot;)&#13;&#10;            .document(movieId)&#13;&#10;            .get()&#13;&#10;            .await()&#13;&#10;            .toObject&lt;Movie&gt;()&#13;&#10;    }&#13;&#10;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/just_for_fun/justforfun/data/repository/ReviewRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/just_for_fun/justforfun/data/repository/ReviewRepository.kt" />
              <option name="updatedContent" value="package com.just_for_fun.justforfun.data.repository&#10;&#10;import com.google.firebase.firestore.FieldValue&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.Query&#10;import com.just_for_fun.justforfun.data.models.user.review.ParentType&#10;import com.just_for_fun.justforfun.data.models.user.review.Reply&#10;import com.just_for_fun.justforfun.data.models.user.review.Review&#10;import com.just_for_fun.justforfun.data.models.user.review.ReviewType&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class ReviewRepository(&#10;    private val db: FirebaseFirestore = FirebaseFirestore.getInstance()&#10;) {&#10;    private val reviewsCol get() = db.collection(&quot;reviews&quot;)&#10;    private val repliesCol get() = db.collection(&quot;replies&quot;)&#10;&#10;    suspend fun addReview(review: Review): String {&#10;        val newId = if (review.id.isNotBlank()) review.id else reviewsCol.document().id&#10;        val createdAt = System.currentTimeMillis()&#10;        val data = reviewToMap(review.copy(id = newId)) + mapOf(&#10;            &quot;createdAt&quot; to createdAt,&#10;            &quot;updatedAt&quot; to createdAt&#10;        )&#10;&#10;        // Write review and update user counters atomically&#10;        db.runTransaction { tr -&gt;&#10;            val reviewRef = reviewsCol.document(newId)&#10;            tr.set(reviewRef, data)&#10;            val userRef = db.collection(&quot;users&quot;).document(review.userId)&#10;            tr.update(userRef, mapOf(&#10;                &quot;reviews&quot; to FieldValue.arrayUnion(newId),&#10;                &quot;totalReviews&quot; to FieldValue.increment(1)&#10;            ))&#10;        }.await()&#10;        return newId&#10;    }&#10;&#10;    suspend fun updateReview(review: Review) {&#10;        val updatedAt = System.currentTimeMillis()&#10;        reviewsCol.document(review.id)&#10;            .update((reviewToMap(review) + mapOf(&quot;updatedAt&quot; to updatedAt)))&#10;            .await()&#10;    }&#10;&#10;    suspend fun deleteReview(reviewId: String, userId: String) {&#10;        db.runTransaction { tr -&gt;&#10;            tr.delete(reviewsCol.document(reviewId))&#10;            tr.update(db.collection(&quot;users&quot;).document(userId), mapOf(&#10;                &quot;reviews&quot; to FieldValue.arrayRemove(reviewId),&#10;                &quot;totalReviews&quot; to FieldValue.increment(-1)&#10;            ))&#10;        }.await()&#10;    }&#10;&#10;    suspend fun getReviewsForMovie(movieId: String, limit: Int = 50): List&lt;Review&gt; {&#10;        val snap = reviewsCol&#10;            .whereEqualTo(&quot;movieId&quot;, movieId)&#10;            .orderBy(&quot;createdAt&quot;, Query.Direction.DESCENDING)&#10;            .limit(limit.toLong())&#10;            .get()&#10;            .await()&#10;        return snap.documents.mapNotNull { mapToReview(it.data ?: emptyMap(), it.id) }&#10;    }&#10;&#10;    suspend fun likeReview(reviewId: String, userId: String, like: Boolean) {&#10;        db.runTransaction { tr -&gt;&#10;            val ref = reviewsCol.document(reviewId)&#10;            val snapshot = tr.get(ref)&#10;            val data = snapshot.data ?: emptyMap()&#10;            val helpful = (data[&quot;helpfulVotes&quot;] as? Number)?.toInt() ?: 0&#10;            val total = (data[&quot;totalVotes&quot;] as? Number)?.toInt() ?: 0&#10;            val newHelpful = if (like) helpful + 1 else helpful&#10;            val newTotal = total + 1&#10;            tr.update(ref, mapOf(&#10;                &quot;helpfulVotes&quot; to newHelpful,&#10;                &quot;totalVotes&quot; to newTotal&#10;            ))&#10;            val userRef = db.collection(&quot;users&quot;).document(userId)&#10;            tr.update(userRef, mapOf(&#10;                &quot;likedReviews&quot; to if (like) FieldValue.arrayUnion(reviewId) else FieldValue.arrayRemove(reviewId)&#10;            ))&#10;        }.await()&#10;    }&#10;&#10;    suspend fun addReply(parentId: String, parentType: ParentType, reply: Reply): String {&#10;        val newId = if (reply.id.isNotBlank()) reply.id else repliesCol.document().id&#10;        val data = replyToMap(reply.copy(id = newId, parentId = parentId, parentType = parentType))&#10;        // Write reply and attach to parent&#10;        db.runTransaction { tr -&gt;&#10;            tr.set(repliesCol.document(newId), data)&#10;            val parentRef = if (parentType == ParentType.REVIEW) reviewsCol.document(parentId) else repliesCol.document(parentId)&#10;            tr.update(parentRef, mapOf(&quot;replies&quot; to FieldValue.arrayUnion(newId)))&#10;            val userRef = db.collection(&quot;users&quot;).document(reply.userId)&#10;            tr.update(userRef, mapOf(&#10;                &quot;replies&quot; to FieldValue.arrayUnion(newId)&#10;            ))&#10;        }.await()&#10;        return newId&#10;    }&#10;&#10;    suspend fun getReplies(parentId: String, limit: Int = 50): List&lt;Reply&gt; {&#10;        val snap = repliesCol&#10;            .whereEqualTo(&quot;parentId&quot;, parentId)&#10;            .orderBy(&quot;timestamp&quot;, Query.Direction.ASCENDING)&#10;            .limit(limit.toLong())&#10;            .get()&#10;            .await()&#10;        return snap.documents.mapNotNull { mapToReply(it.data ?: emptyMap(), it.id) }&#10;    }&#10;&#10;    suspend fun likeReply(replyId: String, userId: String, like: Boolean) {&#10;        db.runTransaction { tr -&gt;&#10;            val ref = repliesCol.document(replyId)&#10;            val snapshot = tr.get(ref)&#10;            val data = snapshot.data ?: emptyMap()&#10;            val likeCount = (data[&quot;likeCount&quot;] as? Number)?.toInt() ?: 0&#10;            val newLikes = if (like) likeCount + 1 else (likeCount - 1).coerceAtLeast(0)&#10;            tr.update(ref, mapOf(&quot;likeCount&quot; to newLikes))&#10;            val userRef = db.collection(&quot;users&quot;).document(userId)&#10;            tr.update(userRef, mapOf(&#10;                &quot;likedReplies&quot; to if (like) FieldValue.arrayUnion(replyId) else FieldValue.arrayRemove(replyId)&#10;            ))&#10;        }.await()&#10;    }&#10;&#10;    private fun reviewToMap(r: Review): Map&lt;String, Any?&gt; = mapOf(&#10;        &quot;id&quot; to r.id,&#10;        &quot;movieId&quot; to r.movieId,&#10;        &quot;userId&quot; to r.userId,&#10;        &quot;userName&quot; to r.userName,&#10;        &quot;userAvatar&quot; to r.userAvatar,&#10;        &quot;rating&quot; to r.rating,&#10;        &quot;title&quot; to r.title,&#10;        &quot;content&quot; to r.content,&#10;        &quot;dateCreated&quot; to r.dateCreated,&#10;        &quot;dateModified&quot; to r.dateModified,&#10;        &quot;isVerifiedPurchase&quot; to r.isVerifiedPurchase,&#10;        &quot;helpfulVotes&quot; to r.helpfulVotes,&#10;        &quot;totalVotes&quot; to r.totalVotes,&#10;        &quot;isSpoiler&quot; to r.isSpoiler,&#10;        &quot;isVerified&quot; to r.isVerified,&#10;        &quot;reviewType&quot; to r.reviewType.name,&#10;        &quot;pros&quot; to r.pros,&#10;        &quot;cons&quot; to r.cons,&#10;        &quot;wouldRecommend&quot; to r.wouldRecommend,&#10;        &quot;watchedDate&quot; to r.watchedDate,&#10;        &quot;watchedWith&quot; to r.watchedWith,&#10;        &quot;watchedWhere&quot; to r.watchedWhere,&#10;        &quot;tags&quot; to r.tags,&#10;        &quot;replies&quot; to r.replies&#10;    )&#10;&#10;    private fun mapToReview(m: Map&lt;String, Any?&gt;, id: String): Review? = try {&#10;        Review(&#10;            id = (m[&quot;id&quot;] as? String) ?: id,&#10;            movieId = m[&quot;movieId&quot;] as String,&#10;            userId = m[&quot;userId&quot;] as String,&#10;            userName = m[&quot;userName&quot;] as? String ?: &quot;&quot;,&#10;            userAvatar = m[&quot;userAvatar&quot;] as? String,&#10;            rating = (m[&quot;rating&quot;] as? Number)?.toFloat() ?: 0f,&#10;            title = m[&quot;title&quot;] as? String,&#10;            content = m[&quot;content&quot;] as? String ?: &quot;&quot;,&#10;            dateCreated = m[&quot;dateCreated&quot;] as? String ?: &quot;&quot;,&#10;            dateModified = m[&quot;dateModified&quot;] as? String,&#10;            isVerifiedPurchase = m[&quot;isVerifiedPurchase&quot;] as? Boolean ?: false,&#10;            helpfulVotes = (m[&quot;helpfulVotes&quot;] as? Number)?.toInt() ?: 0,&#10;            totalVotes = (m[&quot;totalVotes&quot;] as? Number)?.toInt() ?: 0,&#10;            isSpoiler = m[&quot;isSpoiler&quot;] as? Boolean ?: false,&#10;            isVerified = m[&quot;isVerified&quot;] as? Boolean ?: false,&#10;            reviewType = (m[&quot;reviewType&quot;] as? String)?.let { runCatching { ReviewType.valueOf(it) }.getOrNull() } ?: ReviewType.USER,&#10;            pros = (m[&quot;pros&quot;] as? List&lt;*&gt;)?.filterIsInstance&lt;String&gt;() ?: emptyList(),&#10;            cons = (m[&quot;cons&quot;] as? List&lt;*&gt;)?.filterIsInstance&lt;String&gt;() ?: emptyList(),&#10;            wouldRecommend = m[&quot;wouldRecommend&quot;] as? Boolean,&#10;            watchedDate = m[&quot;watchedDate&quot;] as? String,&#10;            watchedWith = m[&quot;watchedWith&quot;] as? String,&#10;            watchedWhere = m[&quot;watchedWhere&quot;] as? String,&#10;            tags = (m[&quot;tags&quot;] as? List&lt;*&gt;)?.filterIsInstance&lt;String&gt;() ?: emptyList(),&#10;            replies = (m[&quot;replies&quot;] as? List&lt;*&gt;)?.filterIsInstance&lt;String&gt;() ?: emptyList()&#10;        )&#10;    } catch (_: Exception) { null }&#10;&#10;    private fun replyToMap(r: Reply): Map&lt;String, Any?&gt; = mapOf(&#10;        &quot;id&quot; to r.id,&#10;        &quot;userId&quot; to r.userId,&#10;        &quot;parentId&quot; to r.parentId,&#10;        &quot;parentType&quot; to r.parentType.name,&#10;        &quot;userProfilePhoto&quot; to r.userProfilePhoto,&#10;        &quot;userName&quot; to r.userName,&#10;        &quot;replyText&quot; to r.replyText,&#10;        &quot;timestamp&quot; to r.timestamp,&#10;        &quot;likeCount&quot; to r.likeCount,&#10;        &quot;dislikeCount&quot; to r.dislikeCount,&#10;        &quot;isLiked&quot; to r.isLiked,&#10;        &quot;isDisliked&quot; to r.isDisliked,&#10;        &quot;replies&quot; to r.replies,&#10;        &quot;isEdited&quot; to r.isEdited,&#10;        &quot;editedTimestamp&quot; to r.editedTimestamp&#10;    )&#10;&#10;    private fun mapToReply(m: Map&lt;String, Any?&gt;, id: String): Reply? = try {&#10;        Reply(&#10;            id = (m[&quot;id&quot;] as? String) ?: id,&#10;            userId = m[&quot;userId&quot;] as String,&#10;            parentId = m[&quot;parentId&quot;] as String,&#10;            parentType = (m[&quot;parentType&quot;] as? String)?.let { runCatching { ParentType.valueOf(it) }.getOrNull() } ?: ParentType.REVIEW,&#10;            userProfilePhoto = m[&quot;userProfilePhoto&quot;] as? String ?: &quot;&quot;,&#10;            userName = m[&quot;userName&quot;] as? String ?: &quot;&quot;,&#10;            replyText = m[&quot;replyText&quot;] as? String ?: &quot;&quot;,&#10;            timestamp = (m[&quot;timestamp&quot;] as? Number)?.toLong() ?: 0L,&#10;            likeCount = (m[&quot;likeCount&quot;] as? Number)?.toInt() ?: 0,&#10;            dislikeCount = (m[&quot;dislikeCount&quot;] as? Number)?.toInt() ?: 0,&#10;            isLiked = m[&quot;isLiked&quot;] as? Boolean ?: false,&#10;            isDisliked = m[&quot;isDisliked&quot;] as? Boolean ?: false,&#10;            replies = (m[&quot;replies&quot;] as? List&lt;*&gt;)?.filterIsInstance&lt;String&gt;() ?: emptyList(),&#10;            isEdited = m[&quot;isEdited&quot;] as? Boolean ?: false,&#10;            editedTimestamp = (m[&quot;editedTimestamp&quot;] as? Number)?.toLong()&#10;        )&#10;    } catch (_: Exception) { null }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>